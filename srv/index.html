<html>
    <head>
        <title>Spherical harmonics</title>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <link rel="stylesheet" type="text/css" href="/spherical-harmonics/style/base.css">
        <link rel="stylesheet" type="text/css" href="/spherical-harmonics/style/harmonic-adjuster.css">
        <meta charset="UTF-8">
    </head>
    <body>
        <canvas id="glCanvas" width="640" height="480"></canvas><br>

        <div id="harmonic-adjusters">
        </div>

        <button id="refresh-texture">Refresh texture</button>
        <button id="another-harmonic">Add another harmonic</button>

        <p>
            Use keyboard W, A, S, D, ⇧, ⇩ to move the camera
        </p>
        <p>
            Try some of the following!
        </p>
        <ul>
            <li>\(Y_5^0 + Y_{10}^{10}\)</li>
            <li>\(Y_{2}^{2} + Y_{10}^{10}\)</li>
            <li>\(Y_{3}^{0} + Y_{20}^{15}\)</li>
        </ul>

        <script id="texture-vertex-shader" type="notjs">

         attribute vec2 vertex_position;
         varying vec2 texture_coordinates;

         void main()
         {
             gl_Position = vec4( 0.5 + ( vertex_position / 2.0 ), 0, 1 );
             texture_coordinates = vertex_position;
         }
        </script>

        <script id="texture-fragment-shader" type="notjs">
         precision mediump float;

         varying vec2 texture_coordinates;

         uniform sampler2D rho_sampler;
         uniform float screen_scale;

         void main()
         {
             gl_FragColor = texture2D(rho_sampler, vec2(texture_coordinates.x, texture_coordinates.y));
         }
        </script>

        <script id="surface-vertex-shader" type="notjs">
         precision mediump float;

         attribute vec2 vertex_position;
         // attribute vec3 model_position;

         varying vec2 texture_coordinates;
         varying vec3 position_tpr;
         varying vec3 position;

         uniform float amplitude;

         uniform sampler2D rho_sampler_vertex;
         uniform sampler2D x_sampler;
         uniform sampler2D y_sampler;
         uniform sampler2D z_sampler;

         uniform mat4 model;
         uniform mat4 view;
         uniform mat4 proj;

         #define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679

         void main()
         {
             float rho = 1.0 + 0.5 * amplitude * ( 2.0 * texture2D( rho_sampler_vertex, vertex_position.xy ).r - 1.0 );

             // Might be nice to grab these from a texture rather than computing them every time
             // float x = rho * texture( x_sampler, vertex_position.xy ).r;
             // float y = rho * texture( y_sampler, vertex_position.xy ).r;
             // float z = rho * texture( z_sampler, vertex_position.xy ).r;

             float theta = M_PI * vertex_position.x;
             float phi = 2.0 * M_PI * vertex_position.y;

             float x = rho * sin( theta ) * cos( phi );
             float y = rho * sin( theta ) * sin( phi );
             float z = rho * cos( theta );

             vec4 position4 = model * vec4( vec3(x, y, z), 1.0 );
             position = position4.xyz;
             position_tpr = vec3( theta, phi, rho );
             texture_coordinates = vertex_position.xy;

             gl_Position = proj * view * position4;
         }
        </script>

        <script id="surface-fragment-shader" type="notjs">
         precision mediump float;

         varying vec2 texture_coordinates;
         varying vec3 position;
         varying vec3 position_tpr;
         // out vec4 color;

         uniform sampler2D rho_sampler;
         uniform sampler2D normals_sampler;
         uniform float max_amplitude;
         uniform float amplitude;
         uniform vec3 light_position;
         uniform vec3 view_position;

         #define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679

         void old_main()
         {
             float rho = texture2D(rho_sampler, texture_coordinates).r;

             // Goes from -1 to 1
             float normalized_rho = rho * (amplitude / max_amplitude);

             float color_range = 0.3;
             float red = 0.5 + ( color_range * normalized_rho ) / 2.0;

             gl_FragColor = vec4(red, 0, 0.0, 1.0);
         }

         // https://learnopengl.com/Lighting/Basic-Lighting
         void main()
         {
             vec3 lightColor = vec3(1, 1, 1);
             vec3 objectColor = vec3(0.4, 0, 0);
             float ambientStrength = 0.5;
             vec3 ambient = ambientStrength * lightColor;
             float specularStrength = 0.5;

             vec3 normal_tpr = ( 2.0 * texture2D( normals_sampler, texture_coordinates ) - 1.0 ).xyz;
             float rho = position_tpr.z;
             float theta = position_tpr.x;
             float phi = position_tpr.y;

             // We convert unit vectors here, not components
             // http://www.physics.purdue.edu/~jones105/phys310/coordinates.pdf
             vec3 normal_xyz = mat3(
                 rho * cos(theta) * cos(phi), rho * cos(theta) * sin(phi),  rho * sin(theta),
                 -rho * sin(theta) * sin(phi),  rho * sin(theta) * cos(phi),   0,
                 sin(theta) * cos(phi),         sin(theta) * sin(phi),         cos(theta)
             ) * normal_tpr;

             vec3 norm = - normalize(normal_xyz);
             vec3 light_direction = normalize(light_position - position);
             vec3 view_direction = normalize(view_position - position);
             vec3 reflect_direction = reflect(-light_direction, norm);

             float diff = max(dot(norm, light_direction), 0.0);
             vec3 diffuse = diff * lightColor;
             
             float spec = pow(max(dot(view_direction, reflect_direction), 0.0), 64.0);
             vec3 specular = specularStrength * spec * lightColor;

             // For some reason, the specular spot is shown on the y-axis and not the z-axis
             gl_FragColor = vec4( ( ambient + diffuse + specular ) * objectColor, 1.0 );
             /* gl_FragColor = vec4( ( norm / 2.0 ) + 0.5, 1.0 ); */
         }
        </script>

        <script id="base-vertex-shader" type="notjs">

         uniform mat4 model;
         uniform mat4 view;
         uniform mat4 proj;

         #define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
         
         // an attribute will receive data from a buffer
         attribute vec4 a_position;
         
         // all shaders have a main function
         void main() {
             
             // gl_Position is a special variable a vertex shader
             // is responsible for setting
             gl_Position = proj * view * model * a_position;
         }
         
        </script>
        
        <script id="base-fragment-shader" type="notjs">
         
         // fragment shaders don't have a default precision so we need
         // to pick one. mediump is a good default
         precision mediump float;
         
         void main() {
             // gl_FragColor is a special variable a fragment shader
             // is responsible for setting
             gl_FragColor = vec4(1, 0, 0.5, 1); // return redish-purple
         }
        </script>

        <script src="https://cdn.rawgit.com/humbletim/glm-js/31fd034b/build/glm-js.min.js"></script>
        <script src="/spherical-harmonics/js/utilities.js"></script>
        <script src="/spherical-harmonics/js/gl-utilities.js"></script>
        <script src="/spherical-harmonics/js/base.js"></script>
        <script src="/spherical-harmonics/js/controller.js"></script>
    </body>
</html>
